---
title: "RNASeq TSPOKO vs WT splitlm~genotype"
author: 'Author: Lai,Kei Onn (Barron Lab) and Giuseppe D Agostino (Langley Lab)'
date: "10/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(eval = FALSE)
```


```{r}
library(DESeq2)
library(IHW)
library(dplyr)
library(tibble)
library(EnhancedVolcano)
library(tximeta)
library(magrittr)
library(org.Mm.eg.db)
library(fgsea)
library(msigdbr)
library(BioCparallel)
library(tibble)
library(tidyr)
```
Pseudoalignment with Tximeta;
There are 4 sample groups in total
WT injected with PBS, WT injected with LPS,
TSPOKO injected with PBS, TSPO-KO injected with LPS.

2 Factors are involved in study design: genotype(WT, TSPOKO (KO)) and con or condition (PBS, LPS)
```{r}
se<-tximeta(coldata)
edb <- retrieveDb(se)
se.exons <- addExons(se)
gse <- summarizeToGene(se)
gse <- addIds(gse, "REFSEQ", gene=TRUE)

##con refers to "condition" factor which consists of levels PBS and LPS.
gse$con %<>% relevel("PBS")
gse$genotype %<>% relevel("WT")
levels(gse$con)
round( colSums(assay(gse)) / 1e6, 1 )
```

From our counts file,
Differential expression in DESeq2, isolating by condition for each genotype. 
We get counts from gse (summarized experiment) from Tximeta package.

We then isolate by condition for each genotype for differential expression

```{r}
coldata <- colData(gse)
counts.rna<-assay(gse)[["counts"]]
counts.pbs <- counts.rna[,coldata$con == "PBS","names"]
counts.lps <- counts.rna[,coldata$con== "LPS","names"]
coldata.pbs<- coldata[colnames(counts.pbs),]
coldata.lps <- coldata[colnames(counts.lps),]

#designmatrix contrasting KOPBS- WTPBS
dds.pbs <- DESeqDataSetFromMatrix(countData = counts.pbs, colData = coldata.pbs, design = ~genotype)

#designmatrix contrasting KOLPS- WTLPS
dds.lps <- DESeqDataSetFromMatrix(countData = counts.lps, colData = coldata.lps, design = ~genotype)
dds.pbs$genotype <- relevel(dds.pbs$genotype, ref = "WT")
dds.lps$genotype <- relevel(dds.lps$genotype, ref = "WT")


dds.pbs <- DESeq(dds.pbs)
dds.lps <- DESeq(dds.lps)

```

Getting results of differential expressions
```{r}
res.dds.pbs <- results(dds.pbs, contrast = c("genotype", "KO", "WT"), alpha = 0.05)
res.dds.lps <- results(dds.lps, contrast = c("genotype", "KO", "WT"), alpha = 0.05)

res.dds.pbs.sh <- lfcShrink(dds.pbs, res = res.dds.pbs, contrast = c("genotype", "KO", "WT"), type = "ashr")
res.dds.lps.sh <- lfcShrink(dds.lps, res = res.dds.lps, contrast = c("genotype", "KO", "WT"), type = "ashr")

res.dds.pbs.sh <- as.data.frame(res.dds.pbs.sh, stringsAsFactors = FALSE)
res.dds.lps.sh<- as.data.frame(res.dds.lps.sh, stringsAsFactors = FALSE)


res.dds.pbs.sh$stat <- res.dds.pbs[rownames(res.dds.pbs.sh), "stat"]
res.dds.lps.sh$stat <- res.dds.lps[rownames(res.dds.lps.sh),"stat"]

```


Here we annotate genes within the result dataframe from differential expression with Ensembl IDs
```{r}

#make symvbols as rownames of res df
res.dds.pbs.sh<-merge(res.dds.pbs.sh,bm,by.x="row.names",by.y="ensembl_gene_id",all.x=TRUE)

res.dds.lps.sh<-merge(res.dds.lps.sh,bm,by.x="row.names",by.y="ensembl_gene_id",all.x=TRUE)


# Wrangling to set ensembl IDs as rownames of the biomaRt object
nonduppbs<-which(duplicated(res.dds.pbs.sh$mgi_symbol) == FALSE)
res.dds.pbs.sh<-res.dds.pbs.sh[nonduppbs,]
res.dds.pbs.sh<-res.dds.pbs.sh[complete.cases(res.dds.pbs.sh),]
rownames(res.dds.pbs.sh)<-res.dds.pbs.sh$mgi_symbol


nonduplps<-which(duplicated(res.dds.lps.sh$mgi_symbol) == FALSE)
res.dds.lps.sh<-res.dds.lps.sh[nonduplps,]
res.dds.lps.sh<-res.dds.lps.sh[complete.cases(res.dds.lps.sh),]
rownames(res.dds.lps.sh)<-res.dds.lps.sh$mgi_symbol

```


plotting volcanoplots using EnhancedVolcano

Kevin Blighe, Sharmila Rana and Myles Lewis (2020).
  EnhancedVolcano: Publication-ready volcano plots with enhanced
  colouring and labeling. R package version 1.6.0.
  https://github.com/kevinblighe/EnhancedVolcano
  
  
```{r}

volcanokovswtpbs<-EnhancedVolcano(res.dds.pbs.sh,
    lab = NA,
    x = 'log2FoldChange',
    y = 'pvalue',
    xlim = c(-8, 8),
    ylim = c(0,20),
    title = 'TSPOKO vs WT',
    pCutoff = 0.05,
    FCcutoff = 0.5,
    legendPosition = "none",
    border = "full",
    borderWidth = 2.0,
    borderColour = "black",
    gridlines.major = FALSE,
    gridlines.minor = FALSE,
    cutoffLineType="blank",
    pointSize = c(ifelse(res.dds.pbs.sh$log2FoldChange>0.5|res.dds.pbs.sh$log2FoldChange< -0.5, 2, 1)), axisLabSize = 40,
titleLabSize = 50)
dev.off()
```

```{r}

volcanokovswtlps<-EnhancedVolcano(res.dds.lps.sh,
    lab = NA,
    x = 'log2FoldChange',
    y = 'pvalue',
    xlim = c(-8, 8),
    ylim = c(0,20),
    title = 'TSPOKO vs WT+inflammation',
    pCutoff = 0.05,
    FCcutoff = 0.5,
    legendPosition = "none",
    border = "full",
    borderWidth = 2.0,
    borderColour = "black",
    gridlines.major = FALSE,
    gridlines.minor = FALSE,
    cutoffLineType="blank",
    pointSize = c(ifelse(res.dds.lps.sh$log2FoldChange>0.5|res.dds.lps.sh$log2FoldChange< -0.5, 2, 1)), axisLabSize = 40,
titleLabSize = 50)
dev.off()
```

Getting entrez IDs, the necessary identifiers for fgsea
Preparing ranks for our differentially expressed data

```{r}



res.dds.pbs.sh<-merge(res.dds.pbs.sh,entrezbm,by.x="Row.names",by.y="ensembl_gene_id",all.x =TRUE)
res.dds.lps.sh<-merge(res.dds.lps.sh,entrezbm,by.x="Row.names",by.y="ensembl_gene_id",all.x =TRUE)

pbs.ranks.frame <-res.dds.pbs.sh %>% 
  dplyr::select(entrezgene_id.x, stat) %>% 
  na.omit() %>% 
  distinct() %>% 
  group_by(entrezgene_id.x) %>% 
  summarize(stat=mean(stat))

pbs.ranks <- deframe(pbs.ranks.frame)

lps.ranks.frame <-res.dds.lps.sh %>% 
  dplyr::select(entrezgene_id, stat) %>% 
  na.omit() %>% 
  distinct() %>% 
  group_by(entrezgene_id) %>% 
  summarize(stat=mean(stat))

lps.ranks <- deframe(lps.ranks.frame)
```

 Run the GSEA algorithm on all the C5 genesets
 C5 contains GO BP, GO MF and GO CC
 
 FGSEA results were pruned using an in-house script to remove repetitive fGSEA terms and prevent over-correction of nominal p-values during multiple test correction (Giuseppe Dâ€™Agostino, 2020. Doi:https://gdagstn.github.io/pruning.html).
 
Prepare list of genesets 
```{r}

go.genesets <- msigdbr(species = "Mus musculus", category = "C5")

go.genesets = as.data.frame(go.genesets, stringsAsFactors = FALSE)
go.genesets$entrez_gene = as.character(go.genesets$entrez_gene)
go.list <- lapply(unique(go.genesets$gs_name), function(x) 
  go.genesets[go.genesets$gs_name == x, "entrez_gene"])
names(go.list) = unique(go.genesets$gs_name)
go.list[[1]]
```


fgsea without pruning method
```{r}
fgsea.lps.go <- fgsea(pathways = go.list, 
                  stats = lps.ranks,
                  nperm = 10000,
                  BPPARAM = SnowParam())
fgsea.lps.go<-fgsea.lps.go[order(fgsea.lps.go$pval),]
````
Add names and subcategories to the fgsea results table
```{r}
goid_to_name <- as.data.frame(cbind(unique(go.genesets$gs_exact_source), unique(go.genesets$gs_name)))
goid_and_subcat <- as.data.frame(unique(go.genesets[,c("gs_subcat", "gs_exact_source")]))
rownames(goid_and_subcat) <- goid_and_subcat$gs_exact_source
colnames(goid_to_name) <- c("GO_ID", "name")
rownames(goid_to_name) <- goid_to_name$GO_ID
goid_to_name$subcat <- goid_and_subcat[rownames(goid_and_subcat), "gs_subcat"]

fgsea.lps.go$name <- goid_to_name[fgsea.lps.go$pathway, "name"]
fgsea.lps.go$subcat <- goid_to_name[fgsea.lps.go$pathway, "subcat"]
fgsea.lps.go$subcat <- gsub(fgsea.lps.go$subcat, pattern = "GO:", replacement = "")

fgsea.lps.go <- fgsea.lps.go[fgsea.lps.go$subcat != "HPO"] # we remove HP terms because they are not in the GO graph
fgsea.lps.go$padj <- p.adjust(fgsea.lps.go$pval, method = "fdr")
```


Here is the `fgsea` result pruning function: treats significant and non-significant categories separately. 

- Non-significant categories are only kept if they don't have children categories.

- Significant categories are only kept if they do not have enriched children categories

- Adjusted p-values are recalculated on the nominal p-values from the pruned categories.

```{r prune_function}
pruneGO_FGSEA <- function(fgsea_res, 
                         go_sub = c("BP", "MF", "CC"),
                         alpha = 0.05){
  
  fgsea_res <- fgsea_res[which(fgsea_res$subcat == go_sub),]

  if(go_sub == "BP") go_subcategory = GOBPCHILDREN 
    else  if(go_sub == "MF") go_subcategory = GOMFCHILDREN
    else  if(go_sub == "CC") go_subcategory = GOCCCHILDREN 
  
  go_children <- as.list(go_subcategory)
  go_haschildren <- go_children[!is.na(go_children)]
  
  fgsea_res$has_children <- sapply(fgsea_res$pathway, function(x) x %in% names(go_haschildren))

  fgsea_res_sig <- fgsea_res[fgsea_res$pval < alpha,]

  fgsea_res_sig$has_sig_children <- sapply(fgsea_res_sig$pathway, 
                                            function(x) any(go_haschildren[[x]] %in% fgsea_res_sig$pathway))
   
  fgsea_res_sig$keep <- (fgsea_res_sig$has_children == FALSE) | (fgsea_res_sig$has_children == TRUE & fgsea_res_sig$has_sig_children == FALSE) 
  
  fgsea_res_ns_childless <- fgsea_res[which(fgsea_res$pval >= alpha & !fgsea_res$has_children),]

  pruned <- rbind(fgsea_res_sig[fgsea_res_sig$keep,1:11], fgsea_res_ns_childless[,1:11])
  
  pruned$padj_2 <- p.adjust(pruned$pval, method = "fdr")
  
  pruned_len <- length(setdiff(pruned$pathway, fgsea_res_sig$pathway))
  message("Pruned ", pruned_len, " terms.")
  
  return(pruned)
  
 }
```

Prune separately by different subcategory (necessary to look for children in the right DAG)

```{r}
fgsea.lps.go.bp.pruned <- pruneGO_FGSEA(fgsea.lps.go, go_sub = "BP", alpha = 0.05)
fgsea.lps.go.mf.pruned <- pruneGO_FGSEA(fgsea.lps.go, go_sub = "MF", alpha = 0.05)
fgsea.lps.go.cc.pruned <- pruneGO_FGSEA(fgsea.lps.go, go_sub = "CC", alpha = 0.05)
```

Join all tables and perform (without overwriting) fdr correction

```{r join_tables}
fgsea.lps.go.all.pruned <- rbind(fgsea.lps.go.bp.pruned, fgsea.lps.go.mf.pruned, fgsea.lps.go.cc.pruned)
fgsea.lps.go.all.pruned$padj_3 <- p.adjust(fgsea.lps.go.all.pruned$pval, method = 'fdr')
```


```{r}
fgsea.lps.go<- fgsea.lps.go.all.pruned 

#Filtering for signficant terms using subcat BP/CC/MF
fgsea.lps.go<-fgsea.lps.go[fgsea.lps.go$padj_2<0.05,]
fgsea.lps.go=data.frame(fgsea.lps.go, stringsAsFactors = FALSE)

```

After gleaning through all the pathways, we selected keywords representative of the following fgsea terms: 
phagocytosis, mitochondria, and inflammation.
We then filter all pathways that are related to phagocytosis, mitochondria, and inflammation and extract those that are top 20 in terms of FDR significance.
```{r}
fgsea.lps.go.mito <- fgsea.lps.go[grep("oxidative phosphorlyation|mitochondria respiratory|mitochondrial respirasome|reactive oxidative|mitochondrial|mitochondria|electron_transport_chain|NAD",fgsea.lps.go$pathway, ignore.case = TRUE),]%>% arrange(padj) %>% top_n(n=20,wt=padj) %>% mutate(group= c("Mitochondria processes"))


fgsea.lps.go.phago <- fgsea.lps.go[grep("phagocytosis|phagosome|phagocytic|phagolysosome|FC_epsilon|integrin_mediated_signaling|endocytosis|endocytic", fgsea.lps.go$pathway, ignore.case = TRUE),]%>% arrange(padj)%>% top_n(n=20,wt=padj) %>% mutate(group= c("Phagocytosis"))

fgsea.lps.go.lipid <- fgsea.lps.go[grep("lipid|fatty|arachidonic|diacylglycerol|ceramide|cholestrol|icosanoid|sterol biosynthetic",fgsea.lps.go$pathway, ignore.case = TRUE),]%>% arrange(padj)%>% top_n(n=20,wt=padj)%>% mutate(group= c("Lipid metabolism")) 
fgsea.lps.go.lipid=fgsea.lps.go.lipid[!grepl("binding|signaling", fgsea.lps.go.lipid$pathway,ignore.case = TRUE),]

fgsea.lps.go.inflammation <- fgsea.lps.go[grep("inflammation|inflammatory|immune|acute_phase|T_Cell|antigen|B_Cell|bone_marrow|CD4|CD8|CCR|Chemokine|interferon|virus|complement|cytokine|defense|dendritic_cell|glial|granulocyte|hematopoietic|igG|immunoglobulin|interleukin|leukocyte|lipopolysaccharide|lymphocyte|macrophage|mast_cell|MHC|monocyte|myd88|viral|toll_like|bacterium",fgsea.lps.go$pathway, ignore.case = TRUE),] %>% arrange(padj)%>% top_n(n=20,wt=padj) %>% mutate(group= c("Immune processes"))

fgsea.lps.go.top20<-rbind(fgsea.lps.go.lipid,fgsea.lps.go.inflammation,fgsea.lps.go.mito,fgsea.lps.go.phago)

```


 
 